/**
 * Runs as forked child-process
 */
var _ = require('underscore');
var matrixReductionZ2 = require('./matrixReductionZ2');
var Algorithm = require('./Algorithm');
module.exports = new HomologyZ2();

/**
 * This provides an algorithm for computing homology of a given simplicial-complex.
 * The homology takes place over the field Z/2Z and uses matrixReductionZ2.js in order to
 * calculate the range and kernel of the boundary-matrix in each homology dimension.
 * 
 * The advantage over the field Z/2Z is that the boundary matrix only contains 0 or 1, because the 
 * inverse simplex is the simplex itself within the abelian free group generated by the complex.
 * Another very essential easy resulting from it, is that it is not necessary to consider orientation of
 * the simplexes at all.
 */
function HomologyZ2(){
	var scope = this;
	// inheritance
	Algorithm.call(this);
	
	/**
	 * complex:{vertices: [vertex], simplexes: [simplex]}
	 * vertex: {id: number, coord: [number]}
	 * simplex: {id: number, vertices: [vertex.id], dimension: number}
	 * @param: args: {data: complex}
	 * @returns: [number (betty-number)] betty-numbers ordered by homology-dimension.
	 */
	this.start = function(args){
		var result = [];
//		console.log(args.data.simplexes);
		
//		console.log(findMaxDimension(args.data.simplexes));
				
		for(var dim = findMaxDimension(args.data.simplexes); dim >= 0; dim--){
			var boundaryMatrix = createBoundaryMatrix(dim, args.data.simplexes);
			var reducedMatrix = matrixReductionZ2.start({data: boundaryMatrix}).reduced;
			//TODO how to invoke matrixRudction without new child-process (better performance)
			// otherwise Algorithm creates 'start' listerner for process!!
			//Solution: create in an AlgorithmMediator and make the algorithms returning a class only.
			// then the algorithm services invokes the AlgorithmMediator in new child-process.
			// this one is registering a message-event listener.
			// algorithm-service sends message to child (alg-name, data, options, ...)
			// AlgorithmMediator takes this and produces creates and instance of the require algorithm
			// and runs algorithm in its own process by delegating messages from and to.
			// Remove the init-logic in Algorithm.js, this goes to AlgorithmMediator
			// remove sendResult from Algorithm service this goes to into AlgorithmMediator as well
			// and is invoked when alg-instance.start returns with result.
			// then matrixReduction can be used like above but must be initialized by new first.
		}
		
		//TODO test
		var simplexes = [{dimension:2, vertices:[1,2,3]},
		                 {dimension:2, vertices:[2,3,4]}];
		console.log(createBoundaryMatrix(2, simplexes));
		
		//TODO
		scope.sendResult && scope.sendResult(result);
		return result;
	};	
	
	/**
	 * Creates boundary matrix over Z/2Z for given dimension based on given simplexes.
	 * Note, because homology is over Z/2Z, there is not need to consider orientations 
	 * of simplexes.
	 * @param simplexes: [simplex]
	 * @param dimension: integer
	 * @returns [rows[columns]];
	 */
	function createBoundaryMatrix(dimension, simplexes){
		var rowMap = {}; // border-simplex-string (ordered) -> simplex-idx
		simplexes = _.filter(simplexes, function(simplex){
			return simplex.dimension === dimension;
		});
		_.each(simplexes, function(simplex, simplexIdx){
			for(var faceIdx=0; faceIdx<simplex.vertices.length; faceIdx++){
				addToRows(createFace(simplex, faceIdx), simplexIdx);
			} 
		});	

		function createFace(simplex, faceIdx){
			return _.filter(simplex.vertices, function(vertexId, vertexIdx){
				return !(vertexIdx === faceIdx);
			});
		}

		function addToRows(borderSimplexVertices, columnIdx) {
			var sortedBorder = _.sortBy(borderSimplexVertices, function(vertexId) {
				return vertexId;
			});
			var key = JSON.stringify(sortedBorder);
			if(!_.has(rowMap, key)){
				rowMap[key] = [];
				for(var col=0; col<simplexes.length; col++){
					rowMap[key].push(0);
				}
			}
			rowMap[key][columnIdx] = 1;
		}	
		
		return _.values(rowMap);
	};
	
	function findMaxDimension(simplexes){
		return	_.max(simplexes, function(simplex){
			return simplex.dimension;
		}).dimension;
	}
		
	
	/**
	 * This is called in order to stop a running algorithm.
	 */
	this.stop = function(){
		throw new Error('this is abstract');
	};
	
}