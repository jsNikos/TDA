var _ = require('underscore');
var q = require('q');
var utils = require('../utils');
var MatrixReductionZ2 = require('./MatrixReductionZ2');
var Algorithm = require('./Algorithm');
module.exports = HomologyZ2;

/**
 * This provides an algorithm for computing homology of a given simplicial-complex.
 * The homology takes place over the field Z/2Z and uses matrixReductionZ2.js in order to
 * calculate the range and kernel of the boundary-matrix in each homology dimension.
 * 
 * The advantage over the field Z/2Z is that the boundary matrix only contains 0 or 1, because the 
 * inverse simplex is the simplex itself within the abelian free group generated by the complex.
 * Another very essential easy resulting from it, is that it is not necessary to consider orientation of
 * the simplexes at all.
 */
function HomologyZ2(){
	var scope = this;
	// inheritance
	Algorithm.call(this);
	
	/**
	 * complex:{vertices: [vertex], simplexes: [simplex]}
	 * vertex: {id: number, coord: [number]}
	 * simplex: {id: number, vertices: [vertex.id], dimension: number}
	 * @param: args: {data: complex}
	 * @returns: Promise with result: [number (betty-number)] betty-numbers ordered by homology-dimension.
	 */
	this.start = function(args){
		return q.Promise(function(resolve, reject, notify) {
			var betty = [];							
			utils.execTasks(createDimensionIterator(betty, args.data))
				 .then(function(){
					resolve(betty);	
				 })
				 .done(null, reject);
			
			
			//TODO test some bug, homology is negative!!
//			var simplexes = [{dimension:2, vertices:[1,2,3]},
//			                 {dimension:2, vertices:[2,3,4]}];
//			console.log(createBoundaryMatrix(2, simplexes));
//			var simplexes = [{dimension:0, vertices:[1]},
//            {dimension:0, vertices:[2]}];
//console.log(createBoundaryMatrix(0, simplexes));
			
					
		});
	};	
	
	/**
	 * Creates and returns a 'next' function which when called returns a promise which intends to
	 * compute the homology for the next dimension.
	 * This next-iterator is used in conjuction with utils.execTasks.
	 * @param betty: [] - is being filled with homology for each dimension
	 * @param complex: {vertices: [vertex], simplexes: [simplex]}
	 */
	function createDimensionIterator(betty, complex){
		var range = 0; // last computed range
		var	dim = findMaxDimension(complex.simplexes);			
		var matrixReductionZ2 = new MatrixReductionZ2();
		
		// next dimension - when called returns the promise for the computation of the next dimension
		return function(){
			if(dim < 0){					
				return;
			}				
			return q.Promise(function(resolve, reject){
				// dim-0
				if(dim === 0){
					betty.unshift(complex.vertices.length - range);
					dim--;
					resolve();
					return;
				}
				
				// dim > 0
				var boundaryMatrix = createBoundaryMatrix(dim, complex.simplexes);			
				matrixReductionZ2.start({data: boundaryMatrix})
								 .then(function(result){
									 var rangeKernel = extractRangeKernelDim(result.reduced);
									 betty.unshift(rangeKernel.kernel - range);
									 range = rangeKernel.range;
									 dim--;
									 resolve();
								 })
								 .done(null, reject);					
			});
		}
	}
	
	/**
	 * Extracts the dimension of the range and kernal of the given matrix which
	 * is required to be in reduced form.
	 * @param reducedMatrix: [rows[columns]]
	 * @return : {range: number, kernel: number}
	 */
	function extractRangeKernelDim(reducedMatrix){
		var range = 0;
		while(range < reducedMatrix.length && reducedMatrix[range][range] !== 0){
			range++;
		}
		return {range: range, kernel: reducedMatrix.length - range};
	}
	
	/**
	 * Creates boundary matrix over Z/2Z for given dimension based on given simplexes.
	 * Note, because homology is over Z/2Z, there is not need to consider orientations 
	 * of simplexes.
	 * @param simplexes: [simplex]
	 * @param dimension: integer
	 * @returns [rows[columns]];
	 */
	function createBoundaryMatrix(dimension, simplexes){
		var rowMap = {}; // border-simplex-string (ordered) -> simplex-idx
		simplexes = _.filter(simplexes, function(simplex){
			return simplex.dimension === dimension;
		});
		_.each(simplexes, function(simplex, simplexIdx){
			for(var faceIdx=0; faceIdx<simplex.vertices.length; faceIdx++){
				addToRows(createFace(simplex, faceIdx), simplexIdx);
			} 
		});	

		function createFace(simplex, faceIdx){
			return _.filter(simplex.vertices, function(vertexId, vertexIdx){
				return !(vertexIdx === faceIdx);
			});
		}

		function addToRows(borderSimplexVertices, columnIdx) {
			var sortedBorder = _.sortBy(borderSimplexVertices, function(vertexId) {
				return vertexId;
			});
			var key = JSON.stringify(sortedBorder);
			if(!_.has(rowMap, key)){
				rowMap[key] = [];
				for(var col=0; col<simplexes.length; col++){
					rowMap[key].push(0);
				}
			}
			rowMap[key][columnIdx] = 1;
		}	
		
		return _.values(rowMap);
	};
	
	function findMaxDimension(simplexes){
		return	_.max(simplexes, function(simplex){
			return simplex.dimension;
		}).dimension;
	}
		
	
	/**
	 * This is called in order to stop a running algorithm.
	 */
	this.stop = function(){
		throw new Error('this is abstract');
	};
	
}