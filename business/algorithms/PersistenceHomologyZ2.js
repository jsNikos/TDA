var _ = require('underscore');
var q = require('q');
var utils = require('../utils');
var MatrixReductionZ2 = require('./utils/persistenceHomology/MatrixReductionZ2');
var Algorithm = require('./Algorithm');
module.exports = PersistenceHomologyZ2;

/**
 * This provides an algorithm for computing the barcodes of the persistence-homology of a given
 * filtered simplicial-complex.  
 * The homology takes place over the field Z/2Z and calculation is based on the 'matrix reduction algorithm'. 
 * 
 * The general ideas of the algorithm is as follows:
 * - everything is computed in one big matrix and is even read from the reduced form
 * - the matrix corresponds to the boundary operator and is written over all simplexes in all filter-levels of the 
 *   complex.
 * - important: the simplexes considered are sorted by (filter-level, is-face-of)
 *   This is possible because the filtration builds a sub-complex chain  K0 < K1 < K2 < ...
 *   First the simplexes are listed in level 0, and within before each simplex all its face are listed first.
 *   This sorting is applied for the matrix's rows and columns.
 * - because of this sorting the matrix is upper triangular and has only 0 on the diagonal (an entry of 1 means the 
 *   p-border of a p+1-simplex
 * - reduction is only by applying column additions and is made recursively from left to right,
 *   at column j it considers the lowest one (low means high row-index), if in any column before, say j0, (already reduced)
 *   a lowest one is detected which is on the same row (low(j0) = low(j) for j0 < j), column j0 is added to column j.
 * - this way, a column produced with only 0-entries, means it belongs to an linear combination of previous columns and
 *   thus produces a cycle.
 *   A column produced with a lowest one, corresponds to a border.
 * - the clue is now, such a column j with lowest one (border) is responsible for deleting a previous cycle (Zp/Bp),
 *   this cycle is the one produced (as described above, by linear combinations ...) in the column low(j).
 *   Why is this so: for instance considering a filled triangle, the cycle created by the edges is somewhere produced
 *   in column i. When column j is added (in a later filter-level for instance), which corresponds to the simplex 
 *   spanning the whole triangle, this produces a border (because of the sorting non of the previous simplexes can
 *   create together with this a cycle).
 *   This border's column lowest one, low(j) of a p-simplex, is the highest p-1-simplex possible involved 
 *   in creating the border. The means all other p-1-simplexes creating this border are in column before low(j).
 *   But this means as well that (again consider the sorting) column low(j) together with former p-1-cycles build
 *   a cycle by linear combination and this means low(j) must be a cycle-producing column.
 * - that way the matrix, when reduced, allows to read of cycle generator and corresponding destroyer and this all
 *   with the information of the filter-level.
 * - the p-betty diagram is then the living interval (w.r.t filtration) for each generated cycle 
 * 
 * General remark:
 * The advantage over the field Z/2Z is that the boundary matrix only contains 0 or 1, because the 
 * inverse simplex is the simplex itself within the abelian free group generated by the complex.
 * Another very essential easy resulting from it, is that it is not necessary to consider orientation of
 * the simplexes at all.
 */
function PersistenceHomologyZ2(args){
	var scope = this;
	// inheritance
	Algorithm.call(this, args);
	
	/**
	 * Simplexes are required to have filter-level computed already!
	 * Method is by default deep-copying given complex first to ensure original object
	 * to keep untouched.
	 * 
	 * complex:{vertices: [vertex], simplexes: [simplex]}
	 * vertex: {id: number, coord: [number]}
	 * simplex: {vertices: [vertex.id], dimension: number, filterLevel: integer}
	 * 
	 * @param: args: {data: complex}	 
	 * @returns: Promise with result: [bettyDiagram] 
	 * bettyDiagram : {dimension: number, [bettyInterval] }
	 * bettyInterval: {start: filterLevel, end: filterLevel/undefined}
	 */
	this.start = function(args){
		return q.Promise(function(resolve, reject, notify) {
			// deep copy complex
			var complex = JSON.parse(JSON.stringify(args.data));			
			complex.simplexes.sort(sortCriterium);	
			createIdAndIndex(complex.simplexes);
			var matrixReduction = new MatrixReductionZ2();
			var reducedMatrix =	matrixReduction.start({data: createBoundaryMatrix(complex.simplexes)});
			
			
			var boundaryMatrix = createBoundaryMatrix(complex.simplexes);
			resolve({matrix: boundaryMatrix, simplexes: complex.simplexes}); //TODO
			
			//TODO take care of 0-dim cycles the are not contained in matrix but the destroyer if any
//			var betty = [];							
//			utils.execTasks(createDimensionIterator(betty, args.data))
//				 .then(function(){
//					resolve(betty);	
//				 })
//				 .done(null, reject);					
		});
	};	
	
	/**
	 * Enhances simplexes with id which are a json-string of there 
	 * ordered vertex-ids, and a idx-property which refers to the position in the array.
	 */
	function createIdAndIndex(simplexes){
		_.each(simplexes, function(simplex, idx){
			simplex.id = JSON.stringify(simplex.vertices.slice().sort());
			simplex.idx = idx;
		});
	}
	
	/**
	 * Creates boundary matrix for all simplexes for all filter-levels and dimensions.
	 * Note, the matrix is stored sparse, that means only ones are stored, 0 are undefined.
	 * Thus the dimension of the matrix is to be obtained from simplexes.length.
	 * @param simplexes : [simplex]
	 * @returns [rows[columns]];
	 */
	function createBoundaryMatrix(simplexes){
		var matrix = [];
		_.each(simplexes, function(simplex){
			if(simplex.dimension === 0){ return; }
			_.each(simplex.vertices, function(vertexId){
				var faceId = JSON.stringify(_.without(simplex.vertices, vertexId).sort());
				var face = _.find(simplexes, function(simplex){ return simplex.id === faceId; });
				
				if(!matrix[face.idx]){
					matrix[face.idx] = [];					
				}
				matrix[face.idx][simplex.idx] = 1;	
			});				
		});
		return matrix;
	}
	
	/**
	 * Sorts simplexes of a complex by (filter-level, face-of).
	 * @param simplex1 : {dimension: integer, filterLevel: integer, vertices:[integer]}
	 * @param simplex2
	 * @return <0 when simplex1 < simplex2
	 */
	function sortCriterium(simplex1, simplex2){
		// check filter-level
		var levelDiff = simplex1.filterLevel - simplex2.filterLevel;
		if(levelDiff){
			return levelDiff;
		}
		
		// check subset by sorting and prunning to same length
		if(simplex2.dimension < simplex1.dimension){
			return 1;
		}		
		var sorted1 = simplex1.vertices.slice().sort();		
		var sub2 = simplex2.vertices.slice().sort().slice(0, simplex1.length);
		var isSubset = JSON.stringify(sorted1) === JSON.stringify(sub2); 
		if(isSubset && simplex1.dimension < simplex2.dimension){
			return -1;
		}	
		
		// it's the same or not comparable
		return 0;
	}	
	
}